<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HIKROBOT——学习笔记4</title>
      <link href="/2024/08/12/HIKROBOT_4/"/>
      <url>/2024/08/12/HIKROBOT_4/</url>
      
        <content type="html"><![CDATA[<h2 id="2024-8-1"><a href="#2024-8-1" class="headerlink" title="2024-8-1"></a>2024-8-1</h2><h3 id="1-相机进Uboot"><a href="#1-相机进Uboot" class="headerlink" title="1.相机进Uboot"></a>1.相机进Uboot</h3><p>接串口线，使用Terminal、xterm或CRT软件，连接串口。相机重新上电，过程不断按住ctrl+U进入</p><h3 id="2-串口升级固件包"><a href="#2-串口升级固件包" class="headerlink" title="2.串口升级固件包"></a>2.串口升级固件包</h3><h4 id="2-1-Printf输出当前设备信息，"><a href="#2-1-Printf输出当前设备信息，" class="headerlink" title="2.1 Printf输出当前设备信息，"></a>2.1 Printf输出当前设备信息，</h4><h4 id="2-2-setenv-参数名"><a href="#2-2-setenv-参数名" class="headerlink" title="2.2 setenv + 参数名"></a>2.2 setenv + 参数名</h4><p>设置PC ip即serverip，<br>设置相机临时ip，即ipaddr，<br>save保存</p><h4 id="2-3-配置tftp服务器（使用tftpd32-exe），用来存储固件包，即选择固件包所在路径。"><a href="#2-3-配置tftp服务器（使用tftpd32-exe），用来存储固件包，即选择固件包所在路径。" class="headerlink" title="2.3 配置tftp服务器（使用tftpd32.exe），用来存储固件包，即选择固件包所在路径。"></a>2.3 配置tftp服务器（使用tftpd32.exe），用来存储固件包，即选择固件包所在路径。</h4><p>Tftp服务器ip同所设置的severip。<br>烧写程序  update<br>reset重启</p><h2 id="2024-8-2"><a href="#2024-8-2" class="headerlink" title="2024-8-2"></a>2024-8-2</h2><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1.互斥锁"></a>1.互斥锁</h3><p>互斥锁（Mutex，Mutual Exclusion）是一种同步机制，用于防止多个线程同时访问或修改共享资源，确保线程安全。<br>它通过锁定和解锁操作来实现对共享资源的互斥访问。</p><h4 id="1-1使用互斥锁的例子"><a href="#1-1使用互斥锁的例子" class="headerlink" title="1.1使用互斥锁的例子"></a>1.1使用互斥锁的例子</h4><p>下面是一个完整的例子，展示了如何使用互斥锁来保护对共享资源的访问：<br> <img src="/img/%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E4%BE%8B.png"></p><h3 id="2-snprintf"><a href="#2-snprintf" class="headerlink" title="2.snprintf"></a>2.snprintf</h3><p>snprintf() 是一个 C 语言标准库函数，用于格式化输出字符串，并将结果写入到指定的缓冲区，<br>与 sprintf() 不同的是，snprintf() 会限制输出的字符数，避免缓冲区溢出。<br> <img src="/img/snprintf.png"></p><h3 id="3-sendto"><a href="#3-sendto" class="headerlink" title="3.sendto"></a>3.sendto</h3><p>sendto 函数是用于在网络编程中通过套接字发送数据的一个重要函数，通常用于无连接的 UDP 协议。<br>下面是关于 sendto 函数的详细解释，包括其原型、参数、返回值以及使用示例。</p><h4 id="3-1-函数原型"><a href="#3-1-函数原型" class="headerlink" title="3.1 函数原型"></a>3.1 函数原型</h4><p>int sendto(int sockfd, const void *buf, size_t len, int flags,<br>                const struct sockaddr *dest_addr, socklen_t addrlen);</p><p>参数说明<br>    1.int sockfd:<br>    •套接字文件描述符，是通过 socket 函数创建的套接字。<br>    •该套接字必须是无连接的（如 UDP 套接字）或已连接的（如 TCP 套接字）。<br>    2.const void *buf:<br>    •指向要发送的数据的缓冲区的指针。<br>    •数据将从这个缓冲区复制并发送。<br>    3.size_t len:<br>    •要发送的数据的字节数（缓冲区的大小）。<br>    4.int flags:<br>    •发送标志，通常设置为 0。可以指定某些特定的发送选项，例如 MSG_CONFIRM 或 MSG_DONTROUTE。<br>    5.const struct sockaddr *dest_addr:<br>    •指向目标地址的结构体指针，指明数据包的目标 IP 地址和端口号。<br>    6.socklen_t addrlen:<br>    •目标地址结构体的大小，通常使用 sizeof 来获取。</p><p>返回值<br>    •成功: 返回实际发送的字节数（大于 0）。<br>    •失败: 返回 -1，并设置 errno 来指示错误原因。常见的错误包括：<br>    •ENOTCONN: 套接字未连接（对于 TCP 套接字）。<br>    •EHOSTUNREACH: 目标主机不可达。<br>    •EMSGSIZE: 发送的数据包过大。</p><h3 id="4-IDH9000巴枪NTP校时"><a href="#4-IDH9000巴枪NTP校时" class="headerlink" title="4.IDH9000巴枪NTP校时"></a>4.IDH9000巴枪NTP校时</h3><h4 id="4-1-网口设备"><a href="#4-1-网口设备" class="headerlink" title="4.1 网口设备"></a>4.1 网口设备</h4><p>使用以太网 IPv4地址<br> <img src="/img/IPv4%E5%9C%B0%E5%9D%80.png"></p><h4 id="4-2-U口设备"><a href="#4-2-U口设备" class="headerlink" title="4.2 U口设备"></a>4.2 U口设备</h4><p>巴枪插入电脑后有一个以太网适配器，即此处的IPv4，使用以太网4 IPv4地址进行校时。</p><h3 id="5-gettimeofday"><a href="#5-gettimeofday" class="headerlink" title="5.gettimeofday()"></a>5.gettimeofday()</h3><p>在C语言中可以使用该函数来得到精确时间。精度可以达到微秒，是C标准库的函数。</p><h4 id="5-1-函数原型为："><a href="#5-1-函数原型为：" class="headerlink" title="5.1 函数原型为："></a>5.1 函数原型为：</h4><p> <img src="/img/gettimeofday.png"><br>tv，指向一个timeval的结构体指针，存储获取到的时间；<br>tz，指向一个timezone结构体的指针，存储时区信息，一般为0，被弃用。</p><h3 id="6-setvbuf"><a href="#6-setvbuf" class="headerlink" title="6.setvbuf"></a>6.setvbuf</h3><p>一个 C 标准库函数，用于设置文件流的缓冲区。它允许程序员控制输入和输出流的缓冲模式和缓冲区大小。</p><h4 id="6-1-函数原型为："><a href="#6-1-函数原型为：" class="headerlink" title="6.1 函数原型为："></a>6.1 函数原型为：</h4><p>int setvbuf(FILE *stream, char *buf, int mode, size_t size);<br>》FILE *stream：指向文件流的指针，通常是标准输入（stdin）、标准输出（stdout）或标准错误（stderr）等。<br>》char *buf：指向要用作缓冲区的字符数组。如果设置为 NULL，则使用系统默认的缓冲区。<br>》int mode：指定缓冲模式，有以下几种可能的值：<br>——_IOFBF：全缓冲模式，即在缓冲区满或显式刷新时才进行实际的I&#x2F;O操作。<br>——_IOLBF：行缓冲模式，即在遇到换行符时刷新缓冲区。<br>——_IONBF：无缓冲模式，即每次I&#x2F;O操作都直接进行，不使用缓冲区。<br>——size_t size：指定缓冲区大小（以字节为单位）。如果 buf 为 NULL，则 size 被忽略。</p><h3 id="7-sigset-t"><a href="#7-sigset-t" class="headerlink" title="7.sigset_t"></a>7.sigset_t</h3><p>sigset_t 是一个数据类型，用于表示一组信号。它通常用于设置、检查和操作信号屏蔽字。<br>在处理信号时，使用 sigset_t 可以方便地管理需要阻塞或解除阻塞的信号集合。</p><h4 id="7-1-常用函数"><a href="#7-1-常用函数" class="headerlink" title="7.1 常用函数"></a>7.1 常用函数</h4><p>》sigemptyset(sigset_t *set)：初始化信号集为空。<br>》sigfillset(sigset_t *set)：将所有信号加入信号集。<br>》sigaddset(sigset_t *set, int signum)：将指定的信号加入信号集。<br>》sigdelset(sigset_t *set, int signum)：从信号集中删除指定的信号。<br>》sigismember(const sigset_t *set, int signum)：检查指定的信号是否在信号集中。</p><h3 id="8-prctl"><a href="#8-prctl" class="headerlink" title="8.prctl"></a>8.prctl</h3><p>一个系统调用，用于执行各种进程控制操作。</p><h4 id="8-1-函数原型："><a href="#8-1-函数原型：" class="headerlink" title="8.1 函数原型："></a>8.1 函数原型：</h4><p>int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5);<br>》option：控制操作码，15 表示 PR_SET_NAME，用于设置线程名称。<br>》arg2：传递给操作码的参数，这里是线程名称。</p><h3 id="9-cpu-set-t"><a href="#9-cpu-set-t" class="headerlink" title="9.cpu_set_t"></a>9.cpu_set_t</h3><p>一个数据类型，用于表示一个 CPU 集合，通常用于设置和获取线程或进程的 CPU 亲和性。</p><h4 id="9-1-常用函数"><a href="#9-1-常用函数" class="headerlink" title="9.1 常用函数"></a>9.1 常用函数</h4><p>》CPU_ZERO(cpu_set_t *set)：将 set 初始化为空集，即清除所有 CPU 位。<br>》CPU_SET(int cpu, cpu_set_t *set)：将 cpu 加入到 set 中。<br>》CPU_CLR(int cpu, cpu_set_t *set)：从 set 中移除 cpu。<br>》CPU_ISSET(int cpu, const cpu_set_t *set)：检查 cpu 是否在 set 中。<br>》CPU_COUNT(const cpu_set_t *set)：返回 set 中设置的 CPU 数量。</p><h3 id="10-pthread-setaffinity-np"><a href="#10-pthread-setaffinity-np" class="headerlink" title="10.pthread_setaffinity_np"></a>10.pthread_setaffinity_np</h3><p>pthread_setaffinity_np 是一个非标准的 POSIX 函数，用于设置线程的 CPU 亲和性。</p><h4 id="10-1其原型如下："><a href="#10-1其原型如下：" class="headerlink" title="10.1其原型如下："></a>10.1其原型如下：</h4><p>int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);<br>》pthread_t thread：要设置亲和性的线程，这里使用 pthread_self() 获取当前线程<br>》size_t cpusetsize：cpu_set_t 结构的大小。<br>》const cpu_set_t *cpuset：指向包含 CPU 亲和性信息的 cpu_set_t 结构。</p>]]></content>
      
      
      <categories>
          
          <category> HIKROBOT笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 串口固件包升级 </tag>
            
            <tag> 互斥锁 </tag>
            
            <tag> NTP校时 </tag>
            
            <tag> CPU、线程类等函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HIKROBOT——学习笔记3</title>
      <link href="/2024/08/08/HIKROBOT_3/"/>
      <url>/2024/08/08/HIKROBOT_3/</url>
      
        <content type="html"><![CDATA[<h2 id="2024-7-15"><a href="#2024-7-15" class="headerlink" title="2024-7-15"></a>2024-7-15</h2><h3 id="1-IDMVS加节点流程图"><a href="#1-IDMVS加节点流程图" class="headerlink" title="1.IDMVS加节点流程图"></a>1.IDMVS加节点流程图</h3><p> <img src="/img/IDMVS%E5%8A%A0%E8%8A%82%E7%82%B9.png"></p><h3 id="2-C语言函数"><a href="#2-C语言函数" class="headerlink" title="2.C语言函数"></a>2.C语言函数</h3><h4 id="2-1-memset"><a href="#2-1-memset" class="headerlink" title="2.1 memset"></a>2.1 memset</h4><p>将一块内存区域设置为指定的值。它常用于初始化数组或结构体，尤其是将其所有字节设置为零。<br>void *memset(void *s, int c, size_t n);<br>s<code>：指向要填充的内存块的指针。  c</code>：要设置的值，以整数形式传递，但实际会被转换为无符号字符。<br>n&#96;：要填充的字节数。</p><h4 id="2-2-define-sizeofof-TYPE-MEMBER-sizeof-TYPE-0-MEMBER"><a href="#2-2-define-sizeofof-TYPE-MEMBER-sizeof-TYPE-0-MEMBER" class="headerlink" title="2.2 #define sizeofof(TYPE, MEMBER) (sizeof(((TYPE *)0)-&gt;MEMBER))"></a>2.2 #define sizeofof(TYPE, MEMBER) (sizeof(((TYPE *)0)-&gt;MEMBER))</h4><p>sizeofof(TYPE, MEMBER)<code>：这是一个宏的名称，接受两个参数 </code>TYPE<code>和</code>MEMBER<code>。 (sizeof(((TYPE *)0)-&gt;MEMBER))</code>：这是宏的展开部分。它的作用是计算 <code>TYPE</code> 结构体中 <code>MEMBER</code> 成员的大小。<br>(TYPE *)0<code>**：首先将整数 </code>0<code>强制类型转换为指向</code>TYPE<code> 类型的指针。这是一种常见的技巧，目的是获得一个指向结构体的空指针。 ((TYPE *)0)-&gt;MEMBER</code>**：使用结构体指针访问成员 <code>MEMBER</code>。</p><h4 id="2-3-连接运算符"><a href="#2-3-连接运算符" class="headerlink" title="2.3 ## 连接运算符"></a>2.3 ## 连接运算符</h4><p>“#”的功能是将其后面的宏参数进行字符串化操作。<br>将两个记号（token）粘贴在一起，形成一个新的记号。<br>_name##_handler&#96;</p><h4 id="2-4-memcpy"><a href="#2-4-memcpy" class="headerlink" title="2.4 memcpy"></a>2.4 memcpy</h4><p>void *memcpy(void *dest, const void *src, size_t n);<br>dest<code> 是目标内存的起始地址， src</code> 是源内存的起始地址，<br>n&#96; 是要复制的字节数。</p><h4 id="2-5-define-offsetof-TYPE-MEMBER-unsigned-long-TYPE-0-MEMBER"><a href="#2-5-define-offsetof-TYPE-MEMBER-unsigned-long-TYPE-0-MEMBER" class="headerlink" title="2.5 #define offsetof(TYPE, MEMBER) ((unsigned long) &amp;((TYPE *)0)-&gt;MEMBER)"></a>2.5 #define offsetof(TYPE, MEMBER) ((unsigned long) &amp;((TYPE *)0)-&gt;MEMBER)</h4><p>接受两个参数 <code>TYPE</code> 和 <code>MEMBER</code>。<br>((TYPE *)0)-&gt;MEMBER<code>：使用结构体指针访问成员 </code>MEMBER<code>。由于这是对空指针的访问，不会引发运行时错误，仅仅是在编译时计算成员的偏移量。 &amp;((TYPE *)0)-&gt;MEMBER</code>：获取成员 <code>MEMBER</code> 的地址，即它在结构体中的偏移量。<br>将成员地址转换为 <code>unsigned long</code> 类型，确保它能容纳足够大的值来表示偏移量。<br>unsigned long&#96; 是一个无符号整数类型，通常足够大，可以容纳所有可能的地址偏移量。<br>注意事项：</p><ul><li><strong>编译时计算</strong>：<code>offsetof</code> 宏在编译时计算成员的偏移量，因此不会引发运行时开销。 </li><li><strong>空指针技巧</strong>：使用 <code>(TYPE *)0</code> 转换为指向结构体类型的空指针是一个常见的编程技巧，用于获取结构体成员的偏移量而不涉及实际内存访问。 </li><li><strong>类型转换</strong>：为了确保得到正确的偏移量，使用 <code>(unsigned long)</code> 将指针地址转换为无符号长整型是必要的。 </li><li><strong>适用性</strong>：<code>offsetof</code> 宏通常在编写底层系统程序或需要操作结构体内部成员的通用代码中使用，可以动态地获取结构体成员在内存中的位置信息。</li></ul><h2 id="2024-7-18"><a href="#2024-7-18" class="headerlink" title="2024-7-18"></a>2024-7-18</h2><h3 id="1-C语言"><a href="#1-C语言" class="headerlink" title="1. C语言"></a>1. C语言</h3><h4 id="1-1-static"><a href="#1-1-static" class="headerlink" title="1.1 static"></a>1.1 static</h4><p>-当使用<code>static</code>关键字定义变量时，该变量的作用域被限制在定义它的源文件内。换句话说，这个变量对其他源文件是不可见的。因此，无法直接从其他文件访问<code>static</code>变量。<br>-可以通过提供访问函数来间接访问<code>static</code>变量。可以在定义该变量的文件中编写一些访问函数，并在需要使用这些变量的文件中调用这些函数。</p><h4 id="1-2-define-HIK-UNUSED-x-void-x"><a href="#1-2-define-HIK-UNUSED-x-void-x" class="headerlink" title="1.2 #define HIK_UNUSED(x) (void)x;"></a>1.2 #define HIK_UNUSED(x) (void)x;</h4><ul><li><code>(void)x;</code> 是一个语句，使用了C语言中的<strong>类型转换表达式</strong>，将变量 <code>x</code> 转换为 <code>void</code> 类型。</li><li>这种类型转换通常用于标记编译器，表明我们有意不使用 <code>x</code> 的值，而只是为了防止编译器产生未使用变量的警告。</li></ul><h4 id="1-3-fd-open-name-O-RDONLY-0x400"><a href="#1-3-fd-open-name-O-RDONLY-0x400" class="headerlink" title="1.3 fd &#x3D; open(name, O_RDONLY, 0x400);"></a>1.3 fd &#x3D; open(name, O_RDONLY, 0x400);</h4><ul><li><code>O_RDONLY</code>: 这是一个宏，用于指定文件的打开模式。在这里，<code>O_RDONLY</code> 表示以只读模式打开文件</li><li><code>0x400</code>：这是 <code>open</code> 函数的第三个参数，它是文件的访问模式（file mode）。</li></ul><h4 id="1-4-file-size-lseek-fd-0-SEEK-END"><a href="#1-4-file-size-lseek-fd-0-SEEK-END" class="headerlink" title="1.4 file_size &#x3D; lseek(fd, 0, SEEK_END);"></a>1.4 file_size &#x3D; lseek(fd, 0, SEEK_END);</h4><p>从文件起始位置算到文件末尾，求出文件长度。</p><h4 id="1-5-snprintf"><a href="#1-5-snprintf" class="headerlink" title="1.5 snprintf"></a>1.5 snprintf</h4><p>snprintf() 是一个 C 语言标准库函数，用于格式化输出字符串，并将结果写入到指定的缓冲区，与 sprintf() 不同的是，snprintf() 会限制输出的字符数，避免缓冲区溢出。<br>C 库函数 int snprintf(char *str, size_t size, const char *format, …)<br>设将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断，最多写入 size-1 个字符。<br>snprintf(name, len, “Hikvision_GigE_Vision_%d_V%d_%d_%d.zip”, XML_VERSION, SOFT_MAJOR_VERSION, SOFT_MINOR_VERSION, SOFT_REVISION);<br>-<code>name</code>:  这是目标字符数组</p><ul><li>len是 <code>name</code> 数组的最大长度，即可以写入的字符总数（包括终止的 null 字符 <code>\0</code>）。 - 这个参数用于防止缓冲区溢出，因为 <code>snprintf</code> 会确保不超过这个长度写入。<br>-这行代码的作用是将一个包含特定版本信息的格式化字符串写入到字符数组 <code>name</code> 中，确保不会超过数组的长度 <code>len</code>。</li></ul><h4 id="1-6-ntohs"><a href="#1-6-ntohs" class="headerlink" title="1.6 ntohs"></a>1.6 ntohs</h4><p>一个标准函数，用于将 16 位数值从网络字节序转换为主机字节序。</p><h4 id="1-7-htons"><a href="#1-7-htons" class="headerlink" title="1.7 htons"></a>1.7 htons</h4><p>一个用于将 16 位数值从主机字节序转换为网络字节序的函数。</p><h4 id="1-8-inet-ntoa"><a href="#1-8-inet-ntoa" class="headerlink" title="1.8 inet_ntoa"></a>1.8 inet_ntoa</h4><p>将IPV4地址转换为点分十进制。转换为可读的字符串形式。</p><h4 id="1-9-pthread-t"><a href="#1-9-pthread-t" class="headerlink" title="1.9 pthread_t"></a>1.9 pthread_t</h4><ul><li>POSIX 标准中用于表示线程标识符的类型。</li><li><code>tid</code> 是一个 <code>pthread_t</code> 类型的变量，用于存储线程的标识符。</li></ul><h4 id="1-10-va-list-ap-va-start-ap-args"><a href="#1-10-va-list-ap-va-start-ap-args" class="headerlink" title="1.10 va_list ap;   va_start(ap, args);"></a>1.10 va_list ap;   va_start(ap, args);</h4><ul><li><code>va_list</code> 是一个用于存储可变数量参数信息的类型。通常在使用 <code>stdarg.h</code> 中定义的宏来处理变长参数列表时使用。</li><li><code>ap</code> 是一个 <code>va_list</code> 类型的变量，将用于访问变长参数。</li><li><code>va_start</code> 是一个宏，用于初始化 <code>va_list</code> 变量，使其指向变长参数列表中的第一个参数。</li></ul><h4 id="1-11-va-arg-ap-int"><a href="#1-11-va-arg-ap-int" class="headerlink" title="1.11 va_arg(ap, int)"></a>1.11 va_arg(ap, int)</h4><ul><li>使用 <code>va_arg</code> 宏访问每个参数。<code>va_arg</code> 接受 <code>va_list</code> 变量和参数的类型，返回当前参数的值，并将 <code>ap</code> 指向下一个参数。</li></ul><h4 id="1-12-va-end-ap"><a href="#1-12-va-end-ap" class="headerlink" title="1.12 va_end(ap)"></a>1.12 va_end(ap)</h4><p>结束访问变长参数</p><h4 id="1-13-pthread-attr-t"><a href="#1-13-pthread-attr-t" class="headerlink" title="1.13 pthread_attr_t"></a>1.13 pthread_attr_t</h4><p>线程属性<br>pthread_attr_init: 初始化线程属性对象。<br>pthread_attr_setdetachstate: 设置线程的分离状态（如可连接或分离）。 pthread_attr_setstacksize: 设置线程的堆栈大小。<br>pthread_create: 创建线程时使用属性对象。<br>pthread_attr_destroy: 销毁线程属性对象，释放资源。<br>pthread_join: 等待线程结束（如果线程是可连接的）。</p><h4 id="1-14-int-pthreadSpawn-pthread-t-p-threadID-int-joinable-int-priority-unsigned-int-nStacksize-void-funcptr-char-args-…"><a href="#1-14-int-pthreadSpawn-pthread-t-p-threadID-int-joinable-int-priority-unsigned-int-nStacksize-void-funcptr-char-args-…" class="headerlink" title="1.14 int pthreadSpawn ( pthread_t *p_threadID, int joinable, int priority, unsigned int nStacksize, void *funcptr, char args, … )"></a>1.14 int pthreadSpawn ( pthread_t *p_threadID, int joinable, int priority, unsigned int nStacksize, void *funcptr, char args, … )</h4><p>p_threadID：指向线程类型变量的指针，用于存储线程ID。<br>这个函数用于根据给定的线程属性和参数创建新线程。根据参数的数量选择不同的处理方式：<br>-如果参数少于或等于一个，直接创建线程。<br>-如果参数多于一个，使用包装函数 threadWrapper2 来处理多个参数。</p>]]></content>
      
      
      <categories>
          
          <category> HIKROBOT笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDMVS加节点 </tag>
            
            <tag> C语言函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HIKROBOT——学习笔记2</title>
      <link href="/2024/08/03/HIKROBOT_2/"/>
      <url>/2024/08/03/HIKROBOT_2/</url>
      
        <content type="html"><![CDATA[<h2 id="2024-7-15"><a href="#2024-7-15" class="headerlink" title="2024-7-15"></a>2024-7-15</h2><h3 id="1-Windows搭建ntp服务器"><a href="#1-Windows搭建ntp服务器" class="headerlink" title="1.Windows搭建ntp服务器"></a>1.Windows搭建ntp服务器</h3><p>在Windows中进行NTP时间同步，可以按照以下步骤操作：</p><h4 id="1-打开命令提示符"><a href="#1-打开命令提示符" class="headerlink" title="1) 打开命令提示符"></a>1) 打开命令提示符</h4><p>按 Win + R，输入 cmd，然后按Enter。</p><h4 id="2-配置NTP服务器"><a href="#2-配置NTP服务器" class="headerlink" title="2) 配置NTP服务器"></a>2) 配置NTP服务器</h4><p>w32tm &#x2F;config &#x2F;manualpeerlist:”time.windows.com” &#x2F;syncfromflags:manual &#x2F;reliable:YES &#x2F;update</p><h4 id="3-重启Windows时间服务"><a href="#3-重启Windows时间服务" class="headerlink" title="3) 重启Windows时间服务"></a>3) 重启Windows时间服务</h4><p>重启时间服务以应用更改：<br>net stop w32time<br>net start w32time</p><h4 id="4-手动同步时间"><a href="#4-手动同步时间" class="headerlink" title="4) 手动同步时间"></a>4) 手动同步时间</h4><p>w32tm &#x2F;resync</p><h4 id="5-检查同步状态"><a href="#5-检查同步状态" class="headerlink" title="5) 检查同步状态"></a>5) 检查同步状态</h4><p>w32tm &#x2F;query &#x2F;status<br>通过这些步骤，可以在Windows系统上进行NTP时间同步。</p><h4 id="6-检查是否正常"><a href="#6-检查是否正常" class="headerlink" title="6) 检查是否正常"></a>6) 检查是否正常</h4><p>w32tm &#x2F;stripchart &#x2F;computer:127.0.0.1</p><h3 id="2-如何查看NTP服务器的IP？"><a href="#2-如何查看NTP服务器的IP？" class="headerlink" title="2.如何查看NTP服务器的IP？"></a>2.如何查看NTP服务器的IP？</h3><p>输入w32tm &#x2F;query &#x2F;peers<br>NTP服务器是域名形式，使用nslookup获取IP：nslookup 获取到的域名</p><h3 id="3-如何让windows时间使用NTP服务器同步？"><a href="#3-如何让windows时间使用NTP服务器同步？" class="headerlink" title="3.如何让windows时间使用NTP服务器同步？"></a>3.如何让windows时间使用NTP服务器同步？</h3><p>搜索gpedit.msc，进行计算机中windows时间服务配置，配置NTP客户端，启用NTP并将NTPserver修改为自己的NTP域名，完成配置过程。<br> <img src="/img/NTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5.png"></p><h3 id="4-一维码和二维码主要通过以下方法来保证数据的准确性和完整性："><a href="#4-一维码和二维码主要通过以下方法来保证数据的准确性和完整性：" class="headerlink" title="4.一维码和二维码主要通过以下方法来保证数据的准确性和完整性："></a>4.一维码和二维码主要通过以下方法来保证数据的准确性和完整性：</h3><p>带校验位的一维码广泛应用于零售、物流、库存管理等领域，以确保数据的准确性和可追溯性。</p><h4 id="1）一维码（条形码）"><a href="#1）一维码（条形码）" class="headerlink" title="1）一维码（条形码）"></a>1）一维码（条形码）</h4><p>很多一维码，如EAN-13和UPC码，都会包含一个校验位。这个校验位通过对前面的数字进行特定算法计算得出，用来验证扫描结果的准确性。校验位位于最后一位。<br>》数据完整性：校验位用于检测一维码在读取或传输过程中的错误。<br>》常用算法：常见的校验位算法有：<br>   -奇偶校验：通过统计奇数或偶数个数字来判断。</p><ul><li>Luhn算法：主要用于信用卡号等的校验。</li><li>MOD 10&#x2F;11：在条形码中常用的校验方法。</li></ul><h4 id="2）一维码实例"><a href="#2）一维码实例" class="headerlink" title="2）一维码实例"></a>2）一维码实例</h4><p>假设要编码的数字是<br><code>4  0  0  6  3  8  1  3  3  3  9  3  X</code>：<br>13  12 11 10  9  8  7  6  5  4  3  2  1<br>奇数位和偶数位加权：</p><ul><li>奇数位：9,3, 1, 3, 0, 4 → 9+ 3 + 1 +3+4&#x3D; 20</li><li>偶数位：3, 3, 3, 8, 6,0 → 3<em>3 + 3</em>3 + 3<em>3 + 8</em>3 +0<em>3+6</em>3&#x3D;69<br>计算总和：</li><li>总和 &#x3D; 20 + 69 &#x3D; 89<br>取余计算：</li><li>89 % 10 &#x3D; 9</li><li>校验位 &#x3D; 10 - 9 &#x3D; 1<br>最终，完整的 EAN-13 码为 <code>4006381333931</code>。</li></ul><h4 id="3）冗余编码"><a href="#3）冗余编码" class="headerlink" title="3）冗余编码"></a>3）冗余编码</h4><p>一些条形码会重复编码重要数据，这样即使部分条码损坏，也能通过其他部分恢复数据。</p><h4 id="4）二维码"><a href="#4）二维码" class="headerlink" title="4）二维码"></a>4）二维码</h4><p>》错误纠正：二维码通常使用纠错编码（例如QR码的Reed-Solomon纠错）。它可以纠正一部分的错误数据，确保即使二维码部分损坏，数据也能被正确读取。<br>》数据冗余：二维码的设计包含数据冗余，即同样的信息可能在不同的地方出现，增加了数据恢复的可能性。<br>》校验机制：与一维码类似，二维码也有校验机制，通过一定的算法对数据进行校验，确保扫描过程中数据的准确性。</p><h3 id="5-打包程序固件包"><a href="#5-打包程序固件包" class="headerlink" title="5.打包程序固件包"></a>5.打包程序固件包</h3><h4 id="1）红网连接服务器"><a href="#1）红网连接服务器" class="headerlink" title="1）红网连接服务器"></a>1）红网连接服务器</h4><p>xterm连接服务器，进入自己文件夹的work下</p><h4 id="2）检出程序到work中"><a href="#2）检出程序到work中" class="headerlink" title="2）检出程序到work中"></a>2）检出程序到work中</h4><p>svn co “程序路径”</p><h4 id="3）进入检查的程序文件夹"><a href="#3）进入检查的程序文件夹" class="headerlink" title="3）进入检查的程序文件夹"></a>3）进入检查的程序文件夹</h4><p>cd</p><h4 id="4）对整个工程进行编译"><a href="#4）对整个工程进行编译" class="headerlink" title="4）对整个工程进行编译"></a>4）对整个工程进行编译</h4><p>.&#x2F;build.sh r315 id2013em<br>执行build.sh文件 编译平台为r315 相机型号为id2013em</p><h4 id="5）进入app文件夹下"><a href="#5）进入app文件夹下" class="headerlink" title="5）进入app文件夹下"></a>5）进入app文件夹下</h4><p>cd product&#x2F;app_src&#x2F;app&#x2F;</p><h4 id="6）打包"><a href="#6）打包" class="headerlink" title="6）打包"></a>6）打包</h4><p>.&#x2F;zoo id2013em</p><h4 id="7）发送包到篮网"><a href="#7）发送包到篮网" class="headerlink" title="7）发送包到篮网"></a>7）发送包到篮网</h4><p>cd nfs&#x2F;<br>exchange -p digicap.dav（固件包）</p><h2 id="2024-7-16"><a href="#2024-7-16" class="headerlink" title="2024-7-16"></a>2024-7-16</h2><h3 id="1-Linux指令"><a href="#1-Linux指令" class="headerlink" title="1.Linux指令"></a>1.Linux指令</h3><h4 id="1）-来获取传入的命令行或者传入函数的参数个数。"><a href="#1）-来获取传入的命令行或者传入函数的参数个数。" class="headerlink" title="1）$# 来获取传入的命令行或者传入函数的参数个数。"></a>1）$# 来获取传入的命令行或者传入函数的参数个数。</h4><p>执行 .&#x2F;a.sh a b，则 $# 是 2，而不是 3。</p><h4 id="2）chmod修改文件权限-777和754"><a href="#2）chmod修改文件权限-777和754" class="headerlink" title="2）chmod修改文件权限 777和754"></a>2）chmod修改文件权限 777和754</h4><p> <img src="/img/chmod%E6%9D%83%E9%99%90.png"></p><h4 id="3）export"><a href="#3）export" class="headerlink" title="3）export"></a>3）export</h4><p>  <img src="/img/export.png"></p><h4 id="4-’pwd’"><a href="#4-’pwd’" class="headerlink" title="4)’pwd’"></a>4)’pwd’</h4><p>是一个shell命令，用于输出当前工作目录的绝对路径。</p><h4 id="5）if-f-“-PLATFORM-config”"><a href="#5）if-f-“-PLATFORM-config”" class="headerlink" title="5）if [ ! -f “.&#x2F;${PLATFORM}.config” ]"></a>5）if [ ! -f “.&#x2F;${PLATFORM}.config” ]</h4><p><code>-f</code> 是一个测试操作符，用于检查指定的文件是否存在并且是一个普通文件。<br><code>&quot;./$&#123;PLATFORM&#125;.config&quot;</code>: 这是要检查的文件路径</p><h4 id="6）source-用于在当前Shell会话中读取并执行指定文件的内容。"><a href="#6）source-用于在当前Shell会话中读取并执行指定文件的内容。" class="headerlink" title="6）source: 用于在当前Shell会话中读取并执行指定文件的内容。"></a>6）source: 用于在当前Shell会话中读取并执行指定文件的内容。</h4><h4 id="7-scripts-getlocalversion-sh-PLATFORM-CC-autoversion-h"><a href="#7-scripts-getlocalversion-sh-PLATFORM-CC-autoversion-h" class="headerlink" title="7) .&#x2F;scripts&#x2F;getlocalversion.sh . $PLATFORM $CC &gt; .&#x2F;autoversion.h"></a>7) .&#x2F;scripts&#x2F;getlocalversion.sh . $PLATFORM $CC &gt; .&#x2F;autoversion.h</h4><p><code>.</code> 传递给脚本的第一个参数，通常表示当前目录。<br><code>$PLATFORM</code> 是传递给脚本的第二个参数，表示平台变量（例如：Linux、Windows等）<br><code>$CC</code> 是传递给脚本的第三个参数，表示编译器变量（例如：gcc、clang等）。<br><code>&gt;</code> 表示重定向输出。</p><h4 id="8）mv-autoversion-h-TOP-DIR-product-plat-libs-PLATFORM"><a href="#8）mv-autoversion-h-TOP-DIR-product-plat-libs-PLATFORM" class="headerlink" title="8）mv autoversion.h ${TOP_DIR}&#x2F;product&#x2F;plat_libs&#x2F;${PLATFORM}&#x2F;"></a>8）mv autoversion.h ${TOP_DIR}&#x2F;product&#x2F;plat_libs&#x2F;${PLATFORM}&#x2F;</h4><p>这条命令的作用是： 将 <code>autoversion.h</code> 文件移动到 <code>$&#123;TOP_DIR&#125;/product/plat_libs/$&#123;PLATFORM&#125;/</code> 目录下。<br><code>$&#123;TOP_DIR&#125;</code> 是一个环境变量，表示项目的顶级目录。</p><h4 id="9）SUB-DIRS-”platform-product”"><a href="#9）SUB-DIRS-”platform-product”" class="headerlink" title="9）SUB_DIRS&#x3D;”platform product”"></a>9）SUB_DIRS&#x3D;”platform product”</h4><p>定义一个名为 <code>SUB_DIRS</code> 的变量，其值为 <code>platform</code> 和 <code>product</code>，通常用于后续脚本中对这两个子目录进行操作，例如遍历、编译等。</p><h4 id="10）《echo-e-“—processing-033-34m-dir-033-0m—“》"><a href="#10）《echo-e-“—processing-033-34m-dir-033-0m—“》" class="headerlink" title="10）《echo -e “—processing \033[34m$dir\033[0m—“》"></a>10）《echo -e “—processing \033[34m$dir\033[0m—“》</h4><ul><li><code>echo -e</code> 用于输出包含转义字符的字符串。 </li><li><code>---processing \033[34m$dir\033[0m---</code> 输出当前正在处理的目录名称，并使用 ANSI 转义码将目录名称显示为蓝色（<code>\033[34m</code> 表示蓝色，<code>\033[0m</code> 表示重置颜色）。</li></ul><h4 id="11）《ret-》"><a href="#11）《ret-》" class="headerlink" title="11）《ret&#x3D;$?》:"></a>11）《ret&#x3D;$?》:</h4><ul><li>将 <code>build.sh</code> 脚本的返回值（退出状态码）存储在 <code>ret</code> 变量中。</li></ul><h4 id="12）《if-ret-ne-0-》"><a href="#12）《if-ret-ne-0-》" class="headerlink" title="12）《if [ $ret -ne 0 ]; 》"></a>12）《if [ $ret -ne 0 ]; 》</h4><ul><li>检查 <code>ret</code> 是否不等于 0（0 表示成功，非 0 表示失败）。</li></ul><h4 id="13）《-zoo-1-2-3-4》"><a href="#13）《-zoo-1-2-3-4》" class="headerlink" title="13）《.&#x2F;zoo $1 $2 $3 $4》:"></a>13）《.&#x2F;zoo $1 $2 $3 $4》:</h4><ul><li>执行 <code>zoo</code> 程序，并将传入脚本的前四个参数（如果有）传递给 <code>zoo</code> 程序。</li></ul><h3 id="2-XML元素"><a href="#2-XML元素" class="headerlink" title="2.XML元素"></a>2.XML元素</h3><h4 id="1）Category"><a href="#1）Category" class="headerlink" title="1）Category"></a>1）Category</h4><p>表示一个类别；这个类别可能包含更多子元素和属性，用于进一步描述其配置和行为。</p><ul><li><code>Name=&quot;ReadSetting&quot;</code> 是该类别的名称属性，表示此类别的名称为 <code>ReadSetting</code>。 </li><li><code>NameSpace=&quot;Standard&quot;</code> 是该类别的命名空间属性，表示此类别属于 <code>Standard</code> 命名空间。</li></ul><h4 id="2-ToolTip"><a href="#2-ToolTip" class="headerlink" title="2) ToolTip"></a>2) ToolTip</h4><p>用于提供用户界面中显示的提示信息。当用户在界面上悬停或点击相关设置时，这段提示信息可能会显示出来，帮助用户理解该设置的用途。</p><h4 id="3）Description"><a href="#3）Description" class="headerlink" title="3）Description"></a>3）Description</h4><p>用于描述某个设置、选项或类别的用途和功能。为某个设置或选项提供描述信息, 这段描述信息通常用于文档或用户界面中，帮助用户理解该设置或选项的具体作用和功能。</p><h4 id="4-DisplayName"><a href="#4-DisplayName" class="headerlink" title="4) DisplayName"></a>4) DisplayName</h4><p>用于指定某个设置或选项的显示名称。在用户界面中显示的名称。</p><h4 id="5-Visibility"><a href="#5-Visibility" class="headerlink" title="5) Visibility"></a>5) Visibility</h4><p>定义某个设置或选项在用户界面中的可见性。<br><code>Beginner</code> 是 <code>Visibility</code> 元素的内容，表示该设置或选项的可见性级别。这通常表示该设置或选项适合初学者用户，并将在用户界面中对初学者可见。</p><h4 id="6-ImposedAccessMode"><a href="#6-ImposedAccessMode" class="headerlink" title="6) ImposedAccessMode"></a>6) ImposedAccessMode</h4><p>定义某个设置或选项的强制访问模式。</p><ul><li><code>RO</code> 是 <code>ImposedAccessMode</code> 元素的内容，表示访问模式为“只读” read only</li></ul><h4 id="7-pFeature"><a href="#7-pFeature" class="headerlink" title="7) pFeature"></a>7) pFeature</h4><p>表示一个功能特性。<br><code>RunningMode</code> 是 <code>pFeature</code> 元素的内容，表示具体的功能特性名称。</p><h4 id="8-Group——《Group-Comment-”ReadSetting”》"><a href="#8-Group——《Group-Comment-”ReadSetting”》" class="headerlink" title="8) Group——《Group Comment&#x3D;”ReadSetting”》"></a>8) Group——《Group Comment&#x3D;”ReadSetting”》</h4><p>表示一个分组。</p><ul><li><code>Comment=&quot;ReadSetting&quot;</code> 是该元素的属性，表示为该组添加的注释或说明。</li></ul><h4 id="9）Enumeration"><a href="#9）Enumeration" class="headerlink" title="9）Enumeration"></a>9）Enumeration</h4><p>表示一个枚举类型。<br>枚举类型通常用于定义一组离散的命名值，这些值在代码中可以作为常量使用。</p><h4 id="10）pIsLocked——《pIsLocked》TLParamsLocked《-pIsLocked》"><a href="#10）pIsLocked——《pIsLocked》TLParamsLocked《-pIsLocked》" class="headerlink" title="10）pIsLocked——《pIsLocked》TLParamsLocked《&#x2F;pIsLocked》"></a>10）pIsLocked——《pIsLocked》TLParamsLocked《&#x2F;pIsLocked》</h4><p>表示某个参数或设置的锁定状态。<br>当 <code>TLParamsLocked</code> 为真时，相关的参数或设置将被锁定，用户可能无法更改它们。</p><h4 id="11）TLParamsLocked"><a href="#11）TLParamsLocked" class="headerlink" title="11）TLParamsLocked"></a>11）TLParamsLocked</h4><p>传输层TL需要通过更新TLParamsLocked节点的值来反映DMA状态。在设置DMA之前，需要将TLParamsLocked设置为1来锁定相应的摄像机参数，在抓取完成后再将其设置为0.</p><h4 id="12）pIsAvailable"><a href="#12）pIsAvailable" class="headerlink" title="12）pIsAvailable"></a>12）pIsAvailable</h4><p>表示某种可用性状态的标签。</p><h4 id="13）pValue"><a href="#13）pValue" class="headerlink" title="13）pValue"></a>13）pValue</h4><p>地址值</p><h4 id="14）IntReg"><a href="#14）IntReg" class="headerlink" title="14）IntReg"></a>14）IntReg</h4><p>从寄存器中提取整数。整数寄存器配置项</p><h4 id="15）pInvalidator"><a href="#15）pInvalidator" class="headerlink" title="15）pInvalidator"></a>15）pInvalidator</h4><p>表示一个无效化器的配置项。无效化器通常用于在某些条件下使缓存、会话或某些数据无效。</p><h4 id="16）Endianness"><a href="#16）Endianness" class="headerlink" title="16）Endianness"></a>16）Endianness</h4><p>端口号，大端、小端</p>]]></content>
      
      
      <categories>
          
          <category> HIKROBOT笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTP服务器搭建 </tag>
            
            <tag> 一维码 </tag>
            
            <tag> 二维码 </tag>
            
            <tag> 打包程序固件包 </tag>
            
            <tag> Linux指令 </tag>
            
            <tag> XML元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HIKROBOT——学习笔记1</title>
      <link href="/2024/08/01/HIKROBOT_1/"/>
      <url>/2024/08/01/HIKROBOT_1/</url>
      
        <content type="html"><![CDATA[<h2 id="2024-7-9"><a href="#2024-7-9" class="headerlink" title="2024-7-9"></a>2024-7-9</h2><h3 id="1-Standard-Features-Naming-Convention-SFNC-标准属性名列表"><a href="#1-Standard-Features-Naming-Convention-SFNC-标准属性名列表" class="headerlink" title="1.Standard Features Naming Convention (SFNC)   标准属性名列表"></a>1.Standard Features Naming Convention (SFNC)   标准属性名列表</h3><p>   每个节点有一个Name属性，每个Name存在一个命名空间中<br>   命名空间属性有两个可能值，Custom（可用任何名字）、Standard（用SFNC）</p><h3 id="2-Generic-Interface-for-Cameras-GenIcam-对相机的统一接口"><a href="#2-Generic-Interface-for-Cameras-GenIcam-对相机的统一接口" class="headerlink" title="2.Generic Interface for Cameras (GenIcam) 对相机的统一接口"></a>2.Generic Interface for Cameras (GenIcam) 对相机的统一接口</h3><p>   GenTL(通用传输层)<br>   GenApi(通用应用编程接口)<br>   GenCP(通用控制协议)</p><h3 id="3-Gige-Vision-基于千兆以太网的图像传输协议"><a href="#3-Gige-Vision-基于千兆以太网的图像传输协议" class="headerlink" title="3.Gige Vision: 基于千兆以太网的图像传输协议"></a>3.Gige Vision: 基于千兆以太网的图像传输协议</h3><p>   GeV对不同厂商的图像传输协议进行统一<br>   GeV协议是UDP的上层协议（应用层）<br>   GVCP (GigE Vision Control Protocol)：GeV的控制通道协议，控制设备的运行状态<br>   GVSP：GeV的流通道（数据传输）<br>   DISCOVERY：设备发现<br>   CCP：控制通道优先级寄存器</p><h3 id="4-GVCP"><a href="#4-GVCP" class="headerlink" title="4. GVCP"></a>4. GVCP</h3><p>   req_id：CMD和ACK之间的一一身份核对<br>   Pending：当使能Pending_ACK后，设备端在执行应用发来的命令时，快到达预设的等待时间时，设备会提前发送Pending_ACK，延后应用再次重发指令的时间。<br>   控制通道1个、流通道0-512个、信息通道0-1个<br>   通道是一种用于GigE Vision 设备交换信息的虚链接<br>   一一发送，按顺序</p><h3 id="5-GVSP"><a href="#5-GVSP" class="headerlink" title="5. GVSP"></a>5. GVSP</h3><p>   基于IPv4的UDP传输协议<br>   发送方和接收方的IP数据报，都不能使用任何IP选项<br>   流通道传输的数据以块（Block）为单位，记录帧与帧的先后顺序<br>   UDP不能保证数据包的传送顺序，GVSP的接收方必须有处理出错数据包的能力<br>   当GVSP接收方检测到丢包时，通过PACKETRESEND_CMD启动重发机制<br>   发出去的数据包不会获得确认包，GVSP采用延时的方式实现流控制</p><h3 id="6-Link-Local-Address-LLA-本地链路地址"><a href="#6-Link-Local-Address-LLA-本地链路地址" class="headerlink" title="6. Link-Local Address (LLA) 本地链路地址"></a>6. Link-Local Address (LLA) 本地链路地址</h3><h3 id="7-Optical-Character-Recognition-OCR-光学字符识别"><a href="#7-Optical-Character-Recognition-OCR-光学字符识别" class="headerlink" title="7.Optical Character Recognition (OCR, 光学字符识别)"></a>7.Optical Character Recognition (OCR, 光学字符识别)</h3><p>   电子设备检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程。</p><h2 id="2024-7-10"><a href="#2024-7-10" class="headerlink" title="2024-7-10"></a>2024-7-10</h2><h3 id="1-曝光量：相当于相机的快门"><a href="#1-曝光量：相当于相机的快门" class="headerlink" title="1. 曝光量：相当于相机的快门"></a>1. 曝光量：相当于相机的快门</h3><h3 id="2-帧率：帧率以“帧每秒”（FPS）为单位衡量。设备每秒采集的图像数"><a href="#2-帧率：帧率以“帧每秒”（FPS）为单位衡量。设备每秒采集的图像数" class="headerlink" title="2. 帧率：帧率以“帧每秒”（FPS）为单位衡量。设备每秒采集的图像数"></a>2. 帧率：帧率以“帧每秒”（FPS）为单位衡量。设备每秒采集的图像数</h3><h3 id="3-伽马值："><a href="#3-伽马值：" class="headerlink" title="3. 伽马值："></a>3. 伽马值：</h3><p>   输入值和输出时亮度之间的关系，是图像输出值与输入值关系的斜线。调整图像对比度，降低伽马的数值使暗处亮度提升。</p><h3 id="4-增益："><a href="#4-增益：" class="headerlink" title="4. 增益："></a>4. 增益：</h3><p>   放大倍数，信号输出与输入的比值。增大可提高图像亮度</p><h3 id="5-TOF（Time-Of-Flight）光电技术："><a href="#5-TOF（Time-Of-Flight）光电技术：" class="headerlink" title="5. TOF（Time-Of-Flight）光电技术："></a>5. TOF（Time-Of-Flight）光电技术：</h3><p>   一直测量物体距离的技术</p><h3 id="6-ROI-从被处理的图像中勾勒出需要处理的区域"><a href="#6-ROI-从被处理的图像中勾勒出需要处理的区域" class="headerlink" title="6. ROI 从被处理的图像中勾勒出需要处理的区域"></a>6. ROI 从被处理的图像中勾勒出需要处理的区域</h3><h3 id="7-问题"><a href="#7-问题" class="headerlink" title="7. 问题"></a>7. 问题</h3><p>   参数轮询、格式化输出无法点击选中<br>   光源分路选择下分路时，打开分路补光使能，相机下分路不闪。</p><h2 id="2024-7-11与2024-7-12"><a href="#2024-7-11与2024-7-12" class="headerlink" title="2024-7-11与2024-7-12"></a>2024-7-11与2024-7-12</h2><h3 id="1-降采样："><a href="#1-降采样：" class="headerlink" title="1.降采样："></a>1.降采样：</h3><p>   将数据从一个高的采样率减少到一个低的采样率的过程。<br>   在图像处理中，通过是减少图像的尺寸，意味着去除图像中的某些像素以得到一个更小的版本。<br>   降采样的主要目的是减少数据量和计算复杂性，但可能丢失某些细节信息。</p><h3 id="2-远程连接工具-连接相机时，日志打印"><a href="#2-远程连接工具-连接相机时，日志打印" class="headerlink" title="2.远程连接工具 连接相机时，日志打印"></a>2.远程连接工具 连接相机时，日志打印</h3><p>   (none) login: root<br>   Password:<br>   WARNNING: &#x2F;home&#x2F;shellpid alredy exist!<br>   None of nfsroot found in cmdline.<br>   ~# cd &#x2F;mnt&#x2F;app&#x2F;<br>   &#x2F;mnt&#x2F;app # .&#x2F;toolbox outputopen<br>   outputopen success<br>   &#x2F;mnt&#x2F;app # .&#x2F;toolbox loglevel 4<br>   set loglevel success!     </p><h3 id="3-测试IDH9000项目"><a href="#3-测试IDH9000项目" class="headerlink" title="3.测试IDH9000项目"></a>3.测试IDH9000项目</h3><p>   牛玉翔(98):读码配置、关联资源、光源控制、算法参数、设备升级、设备信息、用户参数<br>   <a href="http://hiktest.hikvision.com.cn/#/projects/787650/dashboard/manager">http://hiktest.hikvision.com.cn/#/projects/787650/dashboard/manager</a></p><h3 id="4-mil："><a href="#4-mil：" class="headerlink" title="4.mil："></a>4.mil：</h3><p>   二维码中线宽的单位  指条码密度（精度）    越小，密度越高</p><h2 id="2024-7-13"><a href="#2024-7-13" class="headerlink" title="2024-7-13"></a>2024-7-13</h2><h3 id="1-NTP（Network-time-protocol）"><a href="#1-NTP（Network-time-protocol）" class="headerlink" title="1.NTP（Network time protocol）"></a>1.NTP（Network time protocol）</h3><p>   一种网络时间同步的协议。旨在确保计算机和其它网络设备具有准确的时间，并通过与时间服务器进行通信同步其时钟。</p><h3 id="2-NTP服务器"><a href="#2-NTP服务器" class="headerlink" title="2.NTP服务器"></a>2.NTP服务器</h3><p>   提供时间服务的特定服务器，通过网络向客户端提供准确的时间信息。这些服务器通常与原子钟或其它高精度时间源同步，以确保提供高度准确的时间。</p><h3 id="3-NTP工作流程"><a href="#3-NTP工作流程" class="headerlink" title="3.NTP工作流程"></a>3.NTP工作流程</h3><p> <img src="/img/NTP%E6%B5%81%E7%A8%8B.png"></p><h3 id="4-计算机的系统时间"><a href="#4-计算机的系统时间" class="headerlink" title="4.计算机的系统时间"></a>4.计算机的系统时间</h3><p> <img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.png"></p><h3 id="5-时间服务器"><a href="#5-时间服务器" class="headerlink" title="5.时间服务器"></a>5.时间服务器</h3><p>   通过更高精密的物理设备，提供高精度时间。时间源如：高精度原子钟，GPS卫星时间、其他时间服务器等。</p><h3 id="6-RTC（实时时钟）"><a href="#6-RTC（实时时钟）" class="headerlink" title="6.RTC（实时时钟）"></a>6.RTC（实时时钟）</h3><p>   安装在电子设备或实现其功能的集成电路上的时钟。<br>   RTC基本上由晶体振荡器和振荡器电路组成。<br>   RTC的特点首先是低功耗</p><h3 id="7-exchange"><a href="#7-exchange" class="headerlink" title="7.exchange"></a>7.exchange</h3><p>   在红网svn查路径，检出文件，将文件放到挂载的共享文件夹，xterm连接共享文件夹，exchange -p 文件名  传输到蓝网；<br>   蓝网传文件到红网可使用文件传输助手、Hiklink；<br>   exchange -g ???</p>]]></content>
      
      
      <categories>
          
          <category> HIKROBOT笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SFNC </tag>
            
            <tag> GVCP </tag>
            
            <tag> GVSP </tag>
            
            <tag> 日志打印 </tag>
            
            <tag> 相机参数 </tag>
            
            <tag> NTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西安</title>
      <link href="/2024/03/24/%E8%A5%BF%E5%AE%89/"/>
      <url>/2024/03/24/%E8%A5%BF%E5%AE%89/</url>
      
        <content type="html"><![CDATA[<h1 id="西安情侣游玩攻略"><a href="#西安情侣游玩攻略" class="headerlink" title="西安情侣游玩攻略"></a>西安情侣游玩攻略</h1><h2 id="one-day"><a href="#one-day" class="headerlink" title="one day"></a>one day</h2><p>广仁寺、露营烧烤</p><h2 id="two-day"><a href="#two-day" class="headerlink" title="two day"></a>two day</h2>]]></content>
      
      
      <categories>
          
          <category> 旅游城市 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宁波</title>
      <link href="/2023/10/31/%E5%AE%81%E6%B3%A2/"/>
      <url>/2023/10/31/%E5%AE%81%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="景点"><a href="#景点" class="headerlink" title="# 景点"></a># 景点</h1><h2 id="1-鹤浦沙滩-象山石浦渔港古城"><a href="#1-鹤浦沙滩-象山石浦渔港古城" class="headerlink" title="1.鹤浦沙滩(象山石浦渔港古城)"></a>1.鹤浦沙滩(象山石浦渔港古城)</h2><h2 id="2-强蛟群岛（亚帆中心）"><a href="#2-强蛟群岛（亚帆中心）" class="headerlink" title="2.强蛟群岛（亚帆中心）"></a>2.强蛟群岛（亚帆中心）</h2><h2 id="3-鼓楼："><a href="#3-鼓楼：" class="headerlink" title="3.鼓楼："></a>3.鼓楼：</h2><p>​      一条美食商业街，免费。</p><h2 id="4-天一阁（月湖，天一阁旁边）"><a href="#4-天一阁（月湖，天一阁旁边）" class="headerlink" title="4.天一阁（月湖，天一阁旁边）"></a>4.天一阁（月湖，天一阁旁边）</h2><p>私家藏书阁，有南国书城美誉，门票30</p><h2 id="5-外滩、外滩大桥（20-30-20-35，21-00-21-05喷泉）"><a href="#5-外滩、外滩大桥（20-30-20-35，21-00-21-05喷泉）" class="headerlink" title="5.外滩、外滩大桥（20.30-20.35，21.00-21.05喷泉）"></a>5.外滩、外滩大桥（20.30-20.35，21.00-21.05喷泉）</h2><p>周边很多哦<strong>西式建筑群、教堂、美术馆</strong>，适合打卡拍照。夜景</p><h2 id="6-城隍庙"><a href="#6-城隍庙" class="headerlink" title="6.城隍庙"></a>6.城隍庙</h2><h2 id="7-博物馆"><a href="#7-博物馆" class="headerlink" title="7.博物馆"></a>7.博物馆</h2><p>免费，提前五天预约</p><h2 id="8-天一广场"><a href="#8-天一广场" class="headerlink" title="8.天一广场"></a>8.天一广场</h2><p>宁波市中心，适合购物、打卡、拍照</p><h2 id="9-东钱湖："><a href="#9-东钱湖：" class="headerlink" title="9.东钱湖："></a>9.东钱湖：</h2><p>比西湖大三倍，宁波后花园，<strong>院士中心、韩岭老街（南塘老街）、利民村打卡</strong></p><h2 id="10-美术馆"><a href="#10-美术馆" class="headerlink" title="10.美术馆"></a>10.美术馆</h2><h2 id="11-月湖公园-天一阁-博物馆-鼓楼-外滩-天一广场-庆安会馆"><a href="#11-月湖公园-天一阁-博物馆-鼓楼-外滩-天一广场-庆安会馆" class="headerlink" title="11.月湖公园-天一阁-博物馆-鼓楼-外滩-天一广场-庆安会馆"></a>11.月湖公园-天一阁-博物馆-鼓楼-外滩-天一广场-庆安会馆</h2><h2 id="12-孝闻街-望京西城墙遗址博物馆-天一阁-南塘老街"><a href="#12-孝闻街-望京西城墙遗址博物馆-天一阁-南塘老街" class="headerlink" title="12.孝闻街-望京西城墙遗址博物馆-天一阁-南塘老街"></a>12.孝闻街-望京西城墙遗址博物馆-天一阁-南塘老街</h2><h2 id="13-富邦广场的摩天轮（万象城摩天轮）"><a href="#13-富邦广场的摩天轮（万象城摩天轮）" class="headerlink" title="13.富邦广场的摩天轮（万象城摩天轮）"></a>13.富邦广场的摩天轮（万象城摩天轮）</h2><p><img src="/2023/10/31/%E5%AE%81%E6%B3%A2/Git\source_posts\ima_1.jpg" alt="ima_1"></p><h2 id="14必去：——-外滩、天一阁、天一广场、月湖"><a href="#14必去：——-外滩、天一阁、天一广场、月湖" class="headerlink" title="14必去：——-外滩、天一阁、天一广场、月湖"></a>14<em>必去：</em>——-外滩、天一阁、天一广场、月湖</h2><h2 id="15-璀璨夜景：-——-鼓楼-天一广场-外滩-三江口-城隍庙"><a href="#15-璀璨夜景：-——-鼓楼-天一广场-外滩-三江口-城隍庙" class="headerlink" title="15.璀璨夜景： ——-鼓楼-天一广场-外滩-三江口-城隍庙"></a>15.<em>璀璨夜景：</em> ——-鼓楼-天一广场-外滩-三江口-城隍庙</h2><h2 id="16-诗情雅意：——-图书管-美术馆-天一广场-天一阁-博物馆"><a href="#16-诗情雅意：——-图书管-美术馆-天一广场-天一阁-博物馆" class="headerlink" title="16.*诗情雅意：——-*图书管-美术馆-天一广场-天一阁-博物馆"></a>16.*诗情雅意：——-*图书管-美术馆-天一广场-天一阁-博物馆</h2><h2 id="17-小众惬意：——-院士中心-利民村-小普陀-韩岭"><a href="#17-小众惬意：——-院士中心-利民村-小普陀-韩岭" class="headerlink" title="17.小众惬意：——-院士中心-利民村-小普陀-韩岭"></a>17.<em>小众惬意：</em>——-院士中心-利民村-小普陀-韩岭</h2><h2 id="18-烟火老宁波：——-永寿街-呼童街-秀水街-孝闻街-图书管-海曙公园"><a href="#18-烟火老宁波：——-永寿街-呼童街-秀水街-孝闻街-图书管-海曙公园" class="headerlink" title="18.烟火老宁波：——-永寿街-呼童街-秀水街-孝闻街-图书管-海曙公园"></a>18.<em>烟火老宁波：</em>——-永寿街-呼童街-秀水街-孝闻街-图书管-海曙公园</h2><h2 id="19-宁波站-鼓楼-城隍庙-美术馆-南塘老街-天一广场-外滩（酒吧一条街）-天主教堂"><a href="#19-宁波站-鼓楼-城隍庙-美术馆-南塘老街-天一广场-外滩（酒吧一条街）-天主教堂" class="headerlink" title="19.宁波站-鼓楼-城隍庙-美术馆-南塘老街-天一广场-外滩（酒吧一条街）-天主教堂"></a>19.宁波站-鼓楼-城隍庙-美术馆-南塘老街-天一广场-外滩（酒吧一条街）-天主教堂</h2><h2 id="20-博物馆-东钱湖-韩玲老街-院士中心-利民村-云赏谷11号街区"><a href="#20-博物馆-东钱湖-韩玲老街-院士中心-利民村-云赏谷11号街区" class="headerlink" title="20.博物馆-东钱湖-韩玲老街-院士中心-利民村-云赏谷11号街区"></a>20.博物馆-东钱湖-韩玲老街-院士中心-利民村-<em>云赏谷11号街区</em></h2><h2 id="21-南塘老街-天一阁-月湖公园-天一广场-鼓楼-美术馆-外滩"><a href="#21-南塘老街-天一阁-月湖公园-天一广场-鼓楼-美术馆-外滩" class="headerlink" title="21.南塘老街-天一阁-月湖公园-天一广场-鼓楼-美术馆-外滩"></a>21.南塘老街-天一阁-月湖公园-天一广场-鼓楼-美术馆-外滩</h2><h2 id="22-PS：小洱海，导航鹰龙海畔大酒店可到，看日落"><a href="#22-PS：小洱海，导航鹰龙海畔大酒店可到，看日落" class="headerlink" title="22.PS：小洱海，导航鹰龙海畔大酒店可到，看日落"></a>22.PS：小洱海，导航鹰龙海畔大酒店可到，看日落</h2><h1 id="美食"><a href="#美食" class="headerlink" title="# 美食"></a># 美食</h1><p>1.汤圆</p><p>2.腊鸭</p><p>3.鲜肉蒸馄饨</p><p>4.宁波烤菜</p><p>5.雪菜大黄鱼</p><p>6.豆腐包</p><p>7.油赞子</p><p>8.年糕</p><p>9.溪口千层饼</p><p>10.本地菜：阿毛饭店、甬上名灶、缸鸭狗、甬上外婆桥</p><p>11.辣哭饼</p><p>12.木木海鲜面</p><p>13.盒糯叽叽</p><p>14.宁波大学步行美食街</p><p>15.东裕夜市一条街</p><p>16.美肤红烧肉</p>]]></content>
      
      
      <categories>
          
          <category> 旅游城市 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
